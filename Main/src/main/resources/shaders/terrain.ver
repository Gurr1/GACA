#version 330

in vec3 pos;
in vec2 tex;
in vec3 nor;
in vec4 tangent;

out float height;

/* Use diffuse map as height map */
uniform sampler2D diffuseMap;

layout (std140) uniform VIEW {
	vec3 CAMPOSWORLD;
	mat4 CAMERA;
	mat4 PERSPECTIVE;
};

layout (std140) uniform TERRAIN_CONSTANTS {
	vec2 RANGES_SQUARED[5];
	float SCALES[10];
	vec2 GRID_SIZE;
	vec2 TERRAIN_SIZE;
	float MAX_HEIGHT;
	int START_RANGE;
};

layout (std140) uniform TERRAIN_NODE {
	int LOD_LEVEL;
	vec2 TERRAIN_POS;
};

// Function prototypes //
vec2 morphVertex(vec2 gridPos, vec2 vertex, float morphValue);

void main(){
	vec2 gridPos = pos.xz;
	vec2 gridPosWorld = gridPos * SCALES[LOD_LEVEL] + TERRAIN_POS;
	
	vec2 camToGridWorldPos = gridPosWorld - CAMPOSWORLD.xz;	// Check distance with height component aswell?
	float distanceToCameraSqr = dot(camToGridWorldPos, camToGridWorldPos);
	
	vec2 squaredRanges = RANGES_SQUARED[START_RANGE + LOD_LEVEL];
	float morphRangeSqr = squaredRanges.x;
	float rangeSqr = squaredRanges.y;
	
	float morphValue = clamp((distanceToCameraSqr - morphRangeSqr) / rangeSqr, 0.0f, 1.0f);
	vec2 morphedVertex = morphVertex(gridPos, gridPosWorld, morphValue);
	
	// Get height correct way?
	height = texture2D(diffuseMap, morphedVertex  / TERRAIN_SIZE).g * MAX_HEIGHT;
	
	vec4 worldPos = vec4(morphedVertex.x, height, morphedVertex.y, 1.0f);
	
	gl_Position = PERSPECTIVE * CAMERA * worldPos;
}

// Morphs vertex from high to low detailed mesh position
//	- gridPos: x, z components of vertex in grid.
//	- vertex: x, z components of vertex in world space
//	- morphValue: morph value
vec2 morphVertex(vec2 gridPos, vec2 vertex, float morphValue){
	return vertex - mod(gridPos, 2.0f) * SCALES[LOD_LEVEL] * morphValue;
}